#' Creates all factor combinations in a factorial design
#'
#' @param levels A number indicating the number of levels for each arm, or a list indicating
#' the number of levels for each arm
#' @param arms The number of arms, if levels is an integer.
#' @returns A list of all factor combinations (stored as numeric vectors) for a given number of arms and
#' levels per arm.
#' @export
create_policies <- function(levels, arms = 0) {
  if (length(levels) == 1) {
    arm1_levels <- seq.int(0, levels)
    level_list <- rep(list(arm1_levels), arms)
  } else {
    # producing all levels for each arm
    level_list <- lapply(levels, function(x) seq.int(0, x))
  }

  df <- expand.grid(level_list)
  asplit(as.matrix(df), 1)
}

#' @title Assign policy labels to data
#' @description Assigns policy labels to data for use in create_policies_from_data. It will
#' assign a unique id to each unique treatment combination present in data.
#'
#' @param data Dataframe containing the treatment assignments
#' @param arm_cols A character vector containing the names of the arm columns
#' @import dplyr
#' @import magrittr
#' @import data.table
#' @export
assign_policy_label <- function(data, arm_cols) {

  # Ensure group_cols is a character vector
  if (!is.character(arm_cols)) {
    stop("group_cols must be a character vector of column names.")
  }

  # Create the policy_label column based on group IDs
  data[, policy_label := .GRP, by = arm_cols]

  return(data)
}

#' @title Assign universal policy labels to data
#' @description Assigns policy labels to data for use in create_policies_from_data. It will
#' assign a unique id to each unique treatment combination present in data.
#'
#' @param data Dataframe containing the treatment assignments
#' @param arm_cols A character vector containing the names of the arm columns
#' @import dplyr
#' @import magrittr
#' @import data.table
#' @export
assign_universal_label <- function(data, arm_cols) {

  setDT(data)
  # Ensure group_cols is a character vector
  if (!is.character(arm_cols)) {
    stop("group_cols must be a character vector of column names.")
  }

  # Create the policy_label column based on group IDs
  data[, universal_label := .GRP, by = arm_cols]

  return(data)
}

#' @title Prep data for use in raggregate_profiles() or find_rashomon_profile()
#' @description Preps data for use in core functions.
#' @param data A dataframe containing the column whose name you supply in value
#' @param value The column name of the y values in data
#' @param arm_cols A character vector containing the names of the arm columns
#' @param R An integer (or vector) denoting the number of levels in each arm. If
#' this value is an integer, it assumes each arm has the same number of levels.
#' @param drop_unobserved_combinations Whether or not to drop factor combinations
#' not observed in the data. If false, will return a dataframe with all factor
#' combinations labelled, with NAs in value column for factor combinations implicitly missing.
#' @export
prep_data <- function(data, arm_cols, value, R, drop_unobserved_combinations = FALSE){

  R_list = lapply(R, function(x) seq.int(0,x-1))
  data[arm_cols] = mapply(factor, x = data[arm_cols], levels = R_list, SIMPLIFY = FALSE)

  data <- tidyr::complete(data, !!!rlang::syms(arm_cols))
  data <- assign_universal_label(data, arm_cols)
  data <- assign_policy_label(data, arm_cols)
  data <- dplyr::mutate(data, dplyr::across(dplyr::all_of(arm_cols), ~ as.numeric(.x) - 1))

  if(drop_unobserved_combinations){
    return(data[!is.na(get(value))])
  }

  data
}

#' @title Generate list of policies present in data
#' Creates all factor combinations in a factorial design from the data, for
#' use downstream in functions that require policy_list as a parameter.
#' @param data Data.table containing the  treatment assignments
#' @param arm_cols A character vector containing the names of the arm columns
#' @import dplyr
#' @import magrittr
#' @import data.table
#' @export
create_policies_from_data <- function(data, arm_cols) {
  dt <- as.data.table(data)
  dt <- dt[, .(policy_label = .GRP), by = arm_cols]
  dt <- unique(dt)
  dt <- dt[order(policy_label)]
  mat <- dt[, !"policy_label", with = FALSE]
  asplit(as.matrix(mat), 1)
}

#'
#' @title Compute Hasse edges.
#' @description Calculates edgelist for Hasse diagram given sigma and a list of factor combinations, as
#' generated by create_policies_from_data(). Each entry in the list will be a
#' length 2 numeric vector (e.g. (i,j)), which indicates there is an edge between policy i
#' and policy j.
#'
#' @param sigma M X R-2 matrix that gives where cuts occur (an entry if 1 is no cut, and 0 if there is)
#' @param policy_list A list of all factorial combinations given by create_policies
#' @returns Edge list of Hasse diagram, specifying which policies are connected in the same pool
#' @export
lattice_edges <- function(sigma, policy_list) {
  num_policies <- length(policy_list)
  edges <- list()

  for (i in 1:(num_policies - 1)) {
    policy_1 <- policy_list[[i]]
    for (j in (i + 1):num_policies) {
      policy_2 <- policy_list[[j]]
      diff_vec <- abs(policy_1 - policy_2)
      diff <- sum(diff_vec) # calculating difference between abs of policy

      if (diff == 1) { # can only be connected if diff == 1

        arm_diff <- which(diff_vec == 1)
        min_dose <- min(policy_1[arm_diff], policy_2[arm_diff], na.rm = TRUE)

        # is a valid edge if dose exists a
        if (!is.na(sigma[arm_diff, min_dose]) & sigma[arm_diff, min_dose] == 1) {
          edges[length(edges) + 1] <- list(c(i, j)) # adds to edge list
        }
      }
    }
  }
  edges
}

#' @title Prune Hasse edges given new sigma
#' @description Prunes adjacencies given by lattice_adjacencies if our pooling structure (sigma) changes
#' in order to reduce computation when exploring all sigmas
#' @param sigma M X R-2 matrix that gives where cuts occur (an entry if 1 is no cut, and 0 if there is)
#' @param edges Edge list of Hasse diagram, as given by the function lattice_adjacencies
#' @param policy_list A list of all factorial combinations given by create_policies

#' @export
prune_edges <- function(sigma, edges, policy_list) {
  new_edges <- list()
  for (x in edges) {
    pol1 <- policy_list[[x[1]]]
    pol2 <- policy_list[[x[2]]]
    diff <- pol1 - pol2
    arm_diff <- which(diff != 0)
    min_dose <- min(pol1[arm_diff], pol2[arm_diff])

    if (sigma[arm_diff, min_dose] == 1) {
      new_edges[length(new_edges) + 1] <- list(c(x[[1]], x[[2]]))
    }
  }
  new_edges
}


#' helper function for use in union_find data structure
#' @noRd
merge_components <- function(parent, x) {
  if (parent[x] == x) {
    return(x)
  }
  return(merge_components(parent, parent[x]))
}

#' @description Returns the pooling structure given a sigma, in the form of a list that gives
#' the pool number for each factorial combination (policy id)
#' @param n The initial number of parent nodes, usually the total number of factorial combinations
#' @param edges The edgelist of the Hasse diagram given by lattice_edges or prune_edges
#' @returns A collections:dict() that gives the pool for each factorial combination (policy id). The key
#' for each element of the list is the index of its occurrence in policy_list (given by create policies),
#' and its value is the pool it is assigned to.
#' @importFrom collections dict
#' @noRd
connected_components <- function(n, edges) {
  parent <- seq.int(from = 1, to = n)

  for (x in edges) {
    comp1 <- merge_components(parent, x[1])
    comp2 <- merge_components(parent, x[2])
    parent[comp1] <- comp2
  }

  # merge all components to
  for (i in 1:n) {
    parent[i] <- merge_components(parent, parent[i])
  }

  all_cc <- collections::dict()
  for (i in 1:n) {
    all_cc$set(i, parent[i])
  }
  all_cc
}


#' @title Initialize sigma matrix
#' @description Helper function used to initialize sigma
#' given M arms and a vector R (or a single number)
#' of levels for each arm
#' @param M the number of arms
#' @param R If the number of levels per arm is constant, an integer of the
#' number of levels. If not, a vector giving the levels for each arm
#' @returns A sigma matrix with 1's in all valid cut locations and NAs if
#' we cannot cut at that location (e.g. the level for that arm does not exist).
#' @export
initialize_sigma <- function(M, R) {
  if (length(R) == 1) {
    return(matrix(1, nrow = M, ncol = R - 2))
  }

  sigma <- matrix(nrow = M, ncol = max(R) - 2)

  for (i in 1:M) {
    for (j in 1:(R[i] - 2)) {
      sigma[i, j] <- 1
    }
  }
  sigma
}
